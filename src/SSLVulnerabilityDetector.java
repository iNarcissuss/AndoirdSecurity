import com.ibm.wala.classLoader.CallSiteReference;
import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.classLoader.ProgramCounter;
import com.ibm.wala.ipa.callgraph.AnalysisScope;
import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.Entrypoint;
import com.ibm.wala.ipa.callgraph.impl.DefaultEntrypoint;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ssa.IR;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.ssa.SymbolTable;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.types.Selector;
import com.ibm.wala.types.TypeReference;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;

/**
 * Created by Jack on 2/23/16.
 */

public class SSLVulnerabilityDetector {
    /**
     * @param hierarchy
     * @param cg
     * @param appHierarchy
     * @param appScope
     * @param vulnerabilities
     * @param manifestPath   @throws Exception - not sure where the exception comes from
*
     */
//    private XmlPullParserFactory xmlFactoryObject = XmlPullParserFactory.newInstance();
//    private XmlPullParser myparser = xmlFactoryObject.newPullParser();

    public static void analyze(CallGraph cg, List<Entrypoint> entrypointsList, IClassHierarchy appHierarchy, AnalysisScope appScope, Vulnerabilities vulnerabilities, String manifestPath) throws Exception {
        System.out.println("--------------------");
        System.out.println("SSLVulnerabilityDetector");
        System.out.println("--------------------");

        // Walk through all paths under resource folder
        final Set<String> xmlSet = new HashSet<>();
        Path p = Paths.get(manifestPath+"/apk/res");
        FileVisitor<Path> fv = new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
                    throws IOException {
                if (file.toString().endsWith(".xml")){
                    xmlSet.add(file.toString());
                }
                return FileVisitResult.CONTINUE;
            }
        };
        try {
            Files.walkFileTree(p, fv);
        } catch (IOException e) {
            e.printStackTrace();
        }

        // find and generate extra entry points
        Set<String> entryPointSet = new HashSet<>();
        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
        for (String path : xmlSet){
            Document document = docBuilder.parse(new File(path));
            NodeList nodeList = document.getElementsByTagName("*");
            for (int i = 0; i < nodeList.getLength(); i++) {
                Node node = nodeList.item(i);
                if (node.getNodeType() == Node.ELEMENT_NODE) {
                    NamedNodeMap attributes = node.getAttributes();
                    for (int j = 0; j < attributes.getLength(); j++){
                        if (attributes.item(j).getNodeName().toString().matches("(android:on)([A-Z])(\\w+)")) {
                            entryPointSet.add(attributes.item(j).getNodeValue().toString()+"(Landroid/view/View;)V");
                        }
                    }
                }
            }
        }

        // printout all found activity entry point
        for (String str : entryPointSet){
            System.out.println(str);
        }

        // print class with entry point
        IClass activityClass = appHierarchy.lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Extension, "Landroid/app/Activity"));
        for (IClass activitySubclass : appHierarchy.computeSubClasses(activityClass.getReference())) {
            if (!activitySubclass.getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
                continue;
            }
//            System.out.println("Activity class: " + activitySubclass.getName().toString());
            Collection<IMethod> declaredMethods = activitySubclass.getDeclaredMethods();
            for (String lifecycle : entryPointSet) {
                IMethod lifecycleMethod = appHierarchy.resolveMethod(activitySubclass, Selector.make(lifecycle));
                if (declaredMethods.contains(lifecycleMethod)) {
                    System.out.println("    resourceLayoutMethod: " + lifecycleMethod.getSignature());
                    entrypointsList.add(new DefaultEntrypoint(lifecycleMethod, appHierarchy));
                }
            }
        }

        cg = VulnerabilityDetector.makeZeroCFACallgraph(entrypointsList, appScope, appHierarchy);

        // instantiate arrayList to initialize SSLVulnerability List object in vulnerabilities
        vulnerabilities.ImproperSSL = new ArrayList<Vulnerabilities.SSLVulnerability>();
        Vulnerabilities.SSLVulnerability sslVulnerability = null;

        // class hierarchy analysis
        IClassHierarchy cha = cg.getClassHierarchy();

        // SSL  signature - may lead false positive
        String sslContextInitSignature = "javax.net.ssl.SSLContext.init([Ljavax/net/ssl/KeyManager;[Ljavax/net/ssl/TrustManager;Ljava/security/SecureRandom;)V";

        // analyze local data and control flow using IR object within CGNode
        Iterator<CGNode> nodeIter = cg.iterator();

        while (nodeIter.hasNext()) {
            CGNode callerNode = nodeIter.next();

            Iterator<CallSiteReference> callSiteIter = callerNode.iterateCallSites();
            while (callSiteIter.hasNext()) {
                CallSiteReference callSite = callSiteIter.next();
                if (callSite.getDeclaredTarget().getSignature().equals(sslContextInitSignature)) {
                    IR callerIR = callerNode.getIR();
                    SymbolTable callerSymbols = callerIR.getSymbolTable();
                    SSAInstruction invokeInstr = callerIR.getPEI(new ProgramCounter(callSite.getProgramCounter()));
                    for (CGNode targetNode : cg.getPossibleTargets(callerNode, callSite)) {

                    }



                    if (callerSymbols.isStringConstant(invokeInstr.getUse(1))) {
                    //callerNode.getDU().getDef(invokeInstr.getUse(2)) -> get the trust manager
                        // callerNode.getDU().getDef(callerNode.getDU().getDef(invokeInstr.getUse(2)).getDef()) -> get initialization

//                        // initialize a new Vulnerabilities.LeakagePath object
//                        leakagePath = new Vulnerabilities.LeakagePath();
//
//                        // fill in leakage information
//                        leakagePath.information = "SMS sent to: " + callerSymbols.getStringValue(invokeInstr.getUse(1));
//                        leakagePath.sink = invokeInstr.toString();
////                        System.out.println("SMS sent to: " + callerSymbols.getStringValue(invokeInstr.getUse(1)));
//
//                        if (callerSymbols.isStringConstant(invokeInstr.getUse(3))) {
//                            leakagePath.isSourceConstant = "true";
//                            leakagePath.source = callerSymbols.getStringValue(invokeInstr.getUse(3));
////                            System.out.println("    text: " + callerSymbols.getStringValue(invokeInstr.getUse(3)));
//                        } else {
//                            // Get DefUse object
//                            DefUse callerDefUse = callerNode.getDU();
//                            SSAInstruction textDefInstr = callerDefUse.getDef(invokeInstr.getUse(3));
//
//                            if (textDefInstr != null) {
//                                leakagePath.source = textDefInstr.toString();
//                                leakagePath.isSourceConstant = "false";
//                                //TODO:  not quite sure how to follow def-use chain, this may not be the correct implementation
//                                leakagePath.isSourceParameter = callerSymbols.isParameter(invokeInstr.getUse(3)) ? "true" : "false";
////                                System.out.println("    text: " + textDefInstr.toString());
//                            }
//                        }
//                        vulnerabilities.PrivacyLeakage.add(leakagePath);
                    }
                }
            }
        }

    }
}

