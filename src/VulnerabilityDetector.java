/**
 * This is the main class project starter files.
 */


import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.ibm.wala.classLoader.*;
import com.ibm.wala.ipa.callgraph.*;
import com.ibm.wala.ipa.callgraph.impl.ClassHierarchyClassTargetSelector;
import com.ibm.wala.ipa.callgraph.impl.ClassHierarchyMethodTargetSelector;
import com.ibm.wala.ipa.callgraph.impl.DefaultContextSelector;
import com.ibm.wala.ipa.callgraph.impl.DefaultEntrypoint;
import com.ibm.wala.ipa.callgraph.propagation.SSAPropagationCallGraphBuilder;
import com.ibm.wala.ipa.callgraph.propagation.cfa.ZeroXCFABuilder;
import com.ibm.wala.ipa.callgraph.propagation.cfa.ZeroXInstanceKeys;
import com.ibm.wala.ipa.cha.ClassHierarchy;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.types.Selector;
import com.ibm.wala.types.TypeReference;
import com.ibm.wala.util.config.AnalysisScopeReader;

import java.util.*;
import java.util.jar.JarFile;
import java.io.PrintWriter;
import java.io.File;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.jar.JarFile;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class VulnerabilityDetector {
    private final String _androidLib = "lib/android.jar";
    private String _appDir = null;

    private final String[] activityLifecycleMethods = {
            "onCreate(Landroid/os/Bundle;)V",
            "onStart()V",
            "onResume()V",
            "onPause()V",
            "onStop()V",
            "onRestart()V",
            "onDestroy()V",
            "onSSLSocketClick(Landroid/view/View;)V"
    };

    /*
     * This program accepts one argument:  the directory in which the APK file was 
     * extracted.  If you have an APK file for an app that you wish to analyze, use
     * the preprocessing scripts first to create the "appDir" that the following code
     * expects.
     */
    public static void main(String[] args) throws Exception {
        System.out.println("Working Directory = " +
                System.getProperty("user.dir"));
        String appDir = "AndroidApplications/Endofday"; // default analysis application
        if (args.length == 0) {
            // do nothing, use default settings
        } else if (args.length == 1) {
            appDir = args[0];
            System.out.println("Analyzing application: "+ appDir);
        } else {
            System.err.println("usage: VulnerabilityDetector <directory of extracted APK>");
            return;
        }
        System.out.println("Starting vulnerability detection for " + appDir);

        VulnerabilityDetector analysis = new VulnerabilityDetector(appDir);
        analysis.analyze();
    }

    public VulnerabilityDetector(String appDir) {
        _appDir = appDir;
    }

    public void analyze() throws Exception {
        String appPath = null;
        String manifestPath = null;

        // Get class files and manifest from APK directory
        String extractedApkPath = _appDir + "/apk";
        File extractedApkDir = new File(extractedApkPath);

        if (extractedApkDir.isDirectory()) {
            appPath = extractedApkPath + "/classes.jar";
            manifestPath = extractedApkPath + "/AndroidManifest.xml";
        } else {
            System.out.println("\nMissing AndroidManifest.xml and/or classes.jar files in target APK directory.");
            return;
        }

        // Load classes in WALA
        AnalysisScope appScope = AnalysisScopeReader.makeJavaBinaryAnalysisScope(appPath, null);
        Module androidMod = new JarFileModule(new JarFile(_androidLib));
        appScope.addToScope(ClassLoaderReference.Extension, androidMod);
        System.out.println(appScope.toString());

        // Create class hierarchy
        IClassHierarchy appHierarchy = ClassHierarchy.make(appScope);

        System.out.println("Class Hierarchy");
        System.out.println("---------------");
        printClassHierarchy(appHierarchy, appHierarchy.getRootClass(), 0);
        System.out.println("======================");

        System.out.println("Lifecycle Methods");
        System.out.println("-----------------");
//        printLifecycleMethods(appHierarchy);
        System.out.println("======================");


        List<Entrypoint> appEntrypoints = getAppEntrypoints(appHierarchy);
        CallGraph cg = makeZeroCFACallgraph(appEntrypoints, appScope, appHierarchy);

        // Create call graph
        System.out.println("Call Graph");
        System.out.println("----------");
//        printCallGraph(cg, cg.getFakeRootNode(), 0);
        System.out.println("======================");

        // Store all detect vulnerabilities in here.  Add more fields to the 
        // Vulnerabilities class if there are extra vulnerabilities (or extra details
        // about a particular vulnerability) that you can detect.
        Vulnerabilities vulnerabilities = new Vulnerabilities();

        // Example (Overprivilege):
        List<Vulnerabilities.UnusedPermission> overprivilegeCases = new ArrayList<Vulnerabilities.UnusedPermission>();
        // Check for cases of overprivilege
        overprivilegeCases.add(new Vulnerabilities.UnusedPermission());
        vulnerabilities.Overprivilege = overprivilegeCases;

        // Handle other vulnerabilities
        SSLVulnerabilityDetector.analyze(cg, vulnerabilities);
        PrivacyLeakageDetector.analyze(cg, vulnerabilities);

        // Print vulnerabilities to output file
        printVulnerabilityOutput(vulnerabilities);
    }

    /*
     * This method prints your output.  You should not need to modify this.
     */
    private void printVulnerabilityOutput(Vulnerabilities vulnerabilities) throws Exception {
        // Do not change the file name for the output file
        PrintWriter writer = new PrintWriter("./output.json");

        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        gson.toJson(vulnerabilities, writer);

        writer.close();
    }

    /*
     * This method prints out class hierarchy
     */
    private void printClassHierarchy(IClassHierarchy cha, IClass currentClass, int level) {
        String indent = "";
        for (int i = 0; i < level; i++) {
            indent += "    ";
        }

        if (currentClass.getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
            System.out.println(indent + currentClass.getName().toString());
        }

        for (IClass subclass : cha.getImmediateSubclasses(currentClass)) {
            if (subclass.getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
                printClassHierarchy(cha, subclass, level + 1);
            } else {
                printClassHierarchy(cha, subclass, level);
            }
        }
    }

    /*
     * This method prints out lifecycle methods
     */
    private void printLifecycleMethods(IClassHierarchy cha) {
        IClass activityClass = cha.lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Extension, "Landroid/app/Activity"));

        for (IClass activitySubclass : cha.computeSubClasses(activityClass.getReference())) {
            if (!activitySubclass.getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
                continue;
            }

            System.out.println("Activity class: " + activitySubclass.getName().toString());

            Collection<IMethod> declaredMethods = activitySubclass.getDeclaredMethods();
            //for (IMethod declaredMethod : declaredMethods) {
            //    System.out.println("    Declared: " + declaredMethod.getSignature());
            //}

            for (String lifecycle : activityLifecycleMethods) {
                IMethod lifecycleMethod = cha.resolveMethod(activitySubclass, Selector.make(lifecycle));
                if (declaredMethods.contains(lifecycleMethod)) {
                    System.out.println("    Lifecycle method: " + lifecycleMethod.getSignature());
                }
            }
        }
    }

    private List<Entrypoint> getAppEntrypoints(IClassHierarchy cha) {
        List<Entrypoint> entrypoints = new ArrayList<Entrypoint>();

        // For now, just get lifecycle handlers
        IClass activityClass = cha.lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Extension, "Landroid/app/Activity"));

        for (IClass activitySubclass : cha.computeSubClasses(activityClass.getReference())) {
            if (!activitySubclass.getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
                continue;
            }

            Collection<IMethod> declaredMethods = activitySubclass.getDeclaredMethods();

            for (String lifecycle : activityLifecycleMethods) {
                IMethod lifecycleMethod = cha.resolveMethod(activitySubclass, Selector.make(lifecycle));

                if (declaredMethods.contains(lifecycleMethod)) {
                    entrypoints.add(new DefaultEntrypoint(lifecycleMethod, cha));
                }
            }
        }
        return entrypoints;
    }

    private CallGraph makeZeroCFACallgraph(Iterable<Entrypoint> entrypoints, AnalysisScope scope, IClassHierarchy cha) {
        try {
            AnalysisOptions options = new AnalysisOptions(scope, entrypoints);
            options.setSelector(new ClassHierarchyMethodTargetSelector(cha));
            options.setSelector(new ClassHierarchyClassTargetSelector(cha));

            SSAPropagationCallGraphBuilder builder = ZeroXCFABuilder.make(cha, options, new AnalysisCache(), new DefaultContextSelector(options, cha), null, ZeroXInstanceKeys.NONE);

            CallGraph cg = builder.makeCallGraph(options, null);
            return cg;

        } catch (Exception e) {
            System.out.println("Error: " + e.toString());
            return null;
        }
    }

    private void printCallGraph(CallGraph cg, CGNode currentNode, int level) {
        String indent = "";
        for (int i = 0; i < level; i++) {
            indent += "    ";
        }

        System.out.println(indent + currentNode.getMethod().getSignature());

        IClassHierarchy cha = cg.getClassHierarchy();
        Iterator<CallSiteReference> callsiteIter = currentNode.iterateCallSites();

        while (callsiteIter.hasNext()) {
            CallSiteReference callsite = callsiteIter.next();
            IMethod calledMethod = cha.resolveMethod(callsite.getDeclaredTarget());

            if (cg.getPossibleTargets(currentNode, callsite).isEmpty()) {
                System.out.println(indent + "    " + callsite.getDeclaredTarget().getSignature());
            } else {
                for (CGNode targetNode : cg.getPossibleTargets(currentNode, callsite)) {
                    if (targetNode.getMethod().getDeclaringClass().getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
                        printCallGraph(cg, targetNode, level + 1);
                    } else {
                        System.out.println(indent + "    " + targetNode.getMethod().getSignature());
                    }
                }
            }
        }
    }

   /*
     * Helper method in case you need to convert component names into type references that 
     * WALA can understand
     */
    private String convertClassNameToWALA(String className) {
        String walaName = "L" + className.replace('.', '/');
        return walaName;
    }
}

