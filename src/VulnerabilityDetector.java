/**
 * This is the main class project starter files.
 */


import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.ibm.wala.classLoader.*;
import com.ibm.wala.ipa.callgraph.*;
import com.ibm.wala.ipa.callgraph.impl.ClassHierarchyClassTargetSelector;
import com.ibm.wala.ipa.callgraph.impl.ClassHierarchyMethodTargetSelector;
import com.ibm.wala.ipa.callgraph.impl.DefaultContextSelector;
import com.ibm.wala.ipa.callgraph.impl.DefaultEntrypoint;
import com.ibm.wala.ipa.callgraph.propagation.SSAPropagationCallGraphBuilder;
import com.ibm.wala.ipa.callgraph.propagation.cfa.ZeroXCFABuilder;
import com.ibm.wala.ipa.callgraph.propagation.cfa.ZeroXInstanceKeys;
import com.ibm.wala.ipa.cha.ClassHierarchy;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.types.Selector;
import com.ibm.wala.types.TypeReference;
import com.ibm.wala.util.config.AnalysisScopeReader;

import java.io.File;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.jar.JarFile;

public class VulnerabilityDetector {
    private final String _androidLib = "lib/android.jar";
    private String _appDir = null;
    private final static String[] _appDirs = {
            "AndroidApplications/com.andymstone.accuratecompass-14",
            "AndroidApplications/com.pocketools.currency-28",
            "AndroidApplications/com.tic_mobile.android.connectfour-4",
            "AndroidApplications/com.yanex.emoticons-21",
            "AndroidApplications/com.zeptolab.ctr.ads-912244",
            "AndroidApplications/DogWars",
            "AndroidApplications/Endofday",
            "AndroidApplications/FakeNetflix",
            "AndroidApplications/org.wopnersoft.unitconverter-69",
            "AndroidApplications/Vulnerabilities/ComponentHijacking",
            "AndroidApplications/Vulnerabilities/IntentSpoofing",
            "AndroidApplications/Vulnerabilities/OverPrivilege",
            "AndroidApplications/Vulnerabilities/PrivacyLeakage",
            "AndroidApplications/Vulnerabilities/SSL",
            "AndroidApplications/Vulnerabilities/UnauthorizedIntentReceipt"
    };
    private final String[] activityLifecycleMethods = {
            "onCreate(Landroid/os/Bundle;)V",
            "onStart()V",
            "onResume()V",
            "onPause()V",
            "onStop()V",
            "onRestart()V",
            "onDestroy()V"

    };
    private final String[] resourceLayoutMethods = {
            "onSSLSocketClick(Landroid/view/View;)V",
            "onClick(Landroid/view/View;)V"
    };

    public static void main(String[] args) throws Exception {
//        System.out.println("Working Directory = " + System.getProperty("user.dir"));
        String _appDir = "";

        List<Vulnerabilities> vulnerabilitiesList = new ArrayList<>();

        if (args.length == 0) {
            // run all vulnerability analysis on all vulnerable applications
            for (int i = 0; i < _appDirs.length; i++){
                _appDir = _appDirs[i];
                System.out.println("Starting vulnerability detection for " + _appDir);
                VulnerabilityDetector analysis = new VulnerabilityDetector(_appDir);
                vulnerabilitiesList.add(analysis.analyze(new Vulnerabilities()));
                // printout newest json array for every iteration
                printVulnerabilityOutput(vulnerabilitiesList);
            }
        } else if (args.length == 1) {
            // run all vulnerability analysis on provided vulnerable application
            _appDir = args[0];
            System.out.println("Starting vulnerability detection for " + _appDir);
            VulnerabilityDetector analysis = new VulnerabilityDetector(_appDir);
            vulnerabilitiesList.add(analysis.analyze(new Vulnerabilities()));
        } else {
            System.err.println("usage: VulnerabilityDetector <directory of extracted APK>");
            return;
        }
        printVulnerabilityOutput(vulnerabilitiesList);
    }

    public VulnerabilityDetector(String appDir) {
        _appDir = appDir;
    }

    public Vulnerabilities analyze(Vulnerabilities vulnerabilities) throws Exception {
        String appPath = null;
        String manifestPath = null;

        // Get class files and manifest from APK directory
        String extractedApkPath = _appDir + "/apk";
        vulnerabilities.appDir = _appDir;

        File extractedApkDir = new File(extractedApkPath);

        if (extractedApkDir.isDirectory()) {
            appPath = extractedApkPath + "/classes.jar";
            manifestPath = extractedApkPath + "/AndroidManifest.xml";
        } else {
            System.out.println("\nMissing AndroidManifest.xml and/or classes.jar files in target APK directory.");
            return null;
        }

        // Load classes in WALA
        AnalysisScope appScope = AnalysisScopeReader.makeJavaBinaryAnalysisScope(appPath, null);
        Module androidMod = new JarFileModule(new JarFile(_androidLib));
        appScope.addToScope(ClassLoaderReference.Extension, androidMod);
//        System.out.println(appScope.toString());

        // Create class hierarchy
        IClassHierarchy appHierarchy = ClassHierarchy.make(appScope);


//        System.out.println("Class Hierarchy");
//        System.out.println("---------------");
//        printClassHierarchy(appHierarchy, appHierarchy.getRootClass(), 0);
//        System.out.println("======================");

//        System.out.println("Lifecycle Methods");
//        System.out.println("-----------------");
//        printLifecycleMethods(appHierarchy);
//        System.out.println("======================");


        List<Entrypoint> appEntrypoints = getAppEntrypoints(appHierarchy);


        CallGraph cg = makeZeroCFACallgraph(appEntrypoints, appScope, appHierarchy);

        // Create call graph
//        System.out.println("Call Graph");
//        System.out.println("----------");
//        printCallGraph(cg, cg.getFakeRootNode(), 0);
//        System.out.println("======================");


        // Call vulnerabilities detectors
//        IntentSpoofingDetector intentAnalysis = new IntentSpoofingDetector(_appDir);
//        intentAnalysis.intentSpoofAnalysis(vulnerabilities, appScope, manifestPath);

//        OverprivilegeDetector overprivilegeDetector = new OverprivilegeDetector(_appDir);
//        overprivilegeDetector.analyze();

        SSLVulnerabilityDetector.analyze(cg, appEntrypoints, appHierarchy, appScope, vulnerabilities, _appDir);
//        PrivacyLeakageDetector.analyze(cg, vulnerabilities);


//        printVulnerabilityOutput(vulnerabilities);
        if (vulnerabilities == null) {
            System.out.println("No vulnerability found in " + extractedApkPath);
        }
        return vulnerabilities;
    }

    /*
     * This method prints your output.  You should not need to modify this.
     */
    private void printVulnerabilityOutput(Vulnerabilities vulnerabilities) throws Exception {
        // Do not change the file name for the output file
        PrintWriter writer = new PrintWriter("./output.json");
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        gson.toJson(vulnerabilities, writer);
        writer.close();
    }

    /*
     * Overloading printVulnerabilityOutput
     */
    private static void printVulnerabilityOutput(List<Vulnerabilities> vulnerabilitiesList) throws Exception {
        // Do not change the file name for the output file
        PrintWriter writer = new PrintWriter("./output.json");
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        gson.toJson(vulnerabilitiesList, writer);
        writer.close();
    }

    /*
     * This method prints out class hierarchy
     */
    private static void printClassHierarchy(IClassHierarchy cha, IClass currentClass, int level) {
        String indent = "";
        for (int i = 0; i < level; i++) {
            indent += "    ";
        }

        if (currentClass.getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
            System.out.println(indent + currentClass.getName().toString());
        }

        for (IClass subclass : cha.getImmediateSubclasses(currentClass)) {
            if (subclass.getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
                printClassHierarchy(cha, subclass, level + 1);
            } else {
                printClassHierarchy(cha, subclass, level);
            }
        }
    }

    /*
     * This method prints out lifecycle methods
     */
    private void printLifecycleMethods(IClassHierarchy cha) {
        IClass activityClass = cha.lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Extension, "Landroid/app/Activity"));

        for (IClass activitySubclass : cha.computeSubClasses(activityClass.getReference())) {
            if (!activitySubclass.getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
                continue;
            }

            System.out.println("Activity class: " + activitySubclass.getName().toString());

            Collection<IMethod> declaredMethods = activitySubclass.getDeclaredMethods();
            //for (IMethod declaredMethod : declaredMethods) {
            //    System.out.println("    Declared: " + declaredMethod.getSignature());
            //}

            for (String lifecycle : activityLifecycleMethods) {
                IMethod lifecycleMethod = cha.resolveMethod(activitySubclass, Selector.make(lifecycle));
                if (declaredMethods.contains(lifecycleMethod)) {
                    System.out.println("    Lifecycle method: " + lifecycleMethod.getSignature());
                }
            }
            for (String lifecycle : resourceLayoutMethods) {
                IMethod lifecycleMethod = cha.resolveMethod(activitySubclass, Selector.make(lifecycle));
                if (declaredMethods.contains(lifecycleMethod)) {
                    System.out.println("    resourceLayoutMethod: " + lifecycleMethod.getSignature());
                }
            }
        }
    }

    private List<Entrypoint> getAppEntrypoints(IClassHierarchy cha) {
        List<Entrypoint> entrypoints = new ArrayList<Entrypoint>();

        // For now, just get lifecycle handlers
        IClass activityClass = cha.lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Extension, "Landroid/app/Activity"));

        for (IClass activitySubclass : cha.computeSubClasses(activityClass.getReference())) {
            if (!activitySubclass.getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
                continue;
            }

            Collection<IMethod> declaredMethods = activitySubclass.getDeclaredMethods();

            // add entry point for activity lifecycle
            for (String lifecycle : activityLifecycleMethods) {
                IMethod lifecycleMethod = cha.resolveMethod(activitySubclass, Selector.make(lifecycle));

                if (declaredMethods.contains(lifecycleMethod)) {
                    entrypoints.add(new DefaultEntrypoint(lifecycleMethod, cha));
                }
            }
//            for (String lifecycle : resourceLayoutMethods) {
//                IMethod lifecycleMethod = cha.resolveMethod(activitySubclass, Selector.make(lifecycle));
//
//                if (declaredMethods.contains(lifecycleMethod)) {
//                    entrypoints.add(new DefaultEntrypoint(lifecycleMethod, cha));
//                }
//            }
        }
        return entrypoints;
    }

    public static CallGraph makeZeroCFACallgraph(Iterable<Entrypoint> entrypoints, AnalysisScope scope, IClassHierarchy cha) {
        try {
            AnalysisOptions options = new AnalysisOptions(scope, entrypoints);
            options.setSelector(new ClassHierarchyMethodTargetSelector(cha));
            options.setSelector(new ClassHierarchyClassTargetSelector(cha));

            SSAPropagationCallGraphBuilder builder = ZeroXCFABuilder.make(cha, options, new AnalysisCache(), new DefaultContextSelector(options, cha), null, ZeroXInstanceKeys.NONE);

            CallGraph cg = builder.makeCallGraph(options, null);
            return cg;

        } catch (Exception e) {
            System.out.println("Error: " + e.toString());
            return null;
        }
    }

    private void printCallGraph(CallGraph cg, CGNode currentNode, int level) {
        String indent = "";
        for (int i = 0; i < level; i++) {
            indent += "    ";
        }

        System.out.println(indent + currentNode.getMethod().getSignature());

        IClassHierarchy cha = cg.getClassHierarchy();
        Iterator<CallSiteReference> callsiteIter = currentNode.iterateCallSites();

        while (callsiteIter.hasNext()) {
            CallSiteReference callsite = callsiteIter.next();
            IMethod calledMethod = cha.resolveMethod(callsite.getDeclaredTarget());

            if (cg.getPossibleTargets(currentNode, callsite).isEmpty()) {
                System.out.println(indent + "    " + callsite.getDeclaredTarget().getSignature());
            } else {
                for (CGNode targetNode : cg.getPossibleTargets(currentNode, callsite)) {
                    if (targetNode.getMethod().getDeclaringClass().getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
                        printCallGraph(cg, targetNode, level + 1);
                    } else {
                        System.out.println(indent + "    " + targetNode.getMethod().getSignature());
                    }
                }
            }
        }
    }

   /*
     * Helper method in case you need to convert component names into type references that 
     * WALA can understand
     */
    private String convertClassNameToWALA(String className) {
        String walaName = "L" + className.replace('.', '/');
        return walaName;
    }
}

